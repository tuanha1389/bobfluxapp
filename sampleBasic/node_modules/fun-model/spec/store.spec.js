"use strict";
var s = require('../src/store');
var tds = require('./todosState');
var d = require('../src/debug');
describe('store', function () {
    beforeEach(function () {
        resetStore();
        d.bootstrap(jasmine.createSpy('debugCallback'));
    });
    it('gets and sets root state if cursor key is rootStateKey', function () {
        s.bootstrap({ some: null });
        var state = { some: 'state' };
        s.setState(s.rootCursor, state);
        expect(s.getState(s.rootCursor)).toBe(state);
    });
    describe('rootCursor', function () {
        it('cursor has empty key', function () {
            expect(s.rootCursor.key).toBe('');
        });
    });
    describe('isExistingCursor', function () {
        describe('for Object', function () {
            beforeEach(function () {
                s.bootstrap({ some: { nested: { state: 'value' } } });
            });
            it('returns true when value exists in state through cursor', function () {
                var exists = s.isExistingCursor({ key: 'some.nested.state' });
                expect(exists).toBeTruthy();
            });
            it('returns false when value does not exist in state through cursor', function () {
                var exists = s.isExistingCursor({ key: 'some.nested.notExistingState' });
                expect(exists).toBeFalsy();
            });
        });
        describe('for Array', function () {
            beforeEach(function () {
                s.bootstrap({ some: { nested: { arrayState: ['value1', 'value2'] } } });
            });
            it('returns true when value exists in state through cursor', function () {
                debugger;
                var exists = s.isExistingCursor({ key: 'some.nested.arrayState.0' });
                expect(exists).toBeTruthy();
            });
            it('returns false when value does not exist in state through cursor', function () {
                var exists = s.isExistingCursor({ key: 'some.nested.arrayState.5' });
                expect(exists).toBeFalsy();
            });
        });
    });
    describe('getState', function () {
        describe('without booting', function () {
            it('throws if key does not exist', function () {
                expect(function () { return s.getState(s.rootCursor); })
                    .toThrow('Default state must be set before first usage through bootstrap(defaultState, () => { yourRenderCallback(); }).');
            });
        });
        describe('with booting', function () {
            beforeEach(function () {
                s.bootstrap({ some: { nested: { state: 'value' } } });
            });
            it('returns nested state by cursor', function () {
                givenStore({ some: { nested: { state: 'value' } } });
                var state = s.getState({ key: 'some.nested.state' });
                expect(state).toBe('value');
            });
            it('returns nested state by cursor when current value of sub state is empty string', function () {
                givenStore({ some: { nested: { state: '' } } });
                var state = s.getState({ key: 'some.nested.state' });
                expect(state).toBe('');
            });
            it('throws if key does not exist', function () {
                expect(function () { return s.getState({ key: 'not.existing.key' }); })
                    .toThrow('State for cursor key (not.existing.key) does not exist.');
            });
        });
        describe('with booting and dynamic/array cursor', function () {
            beforeEach(function () {
                s.bootstrap(tds.default());
            });
            it('returns nested state in the array on specified index', function () {
                givenTodoStore({ todos: [{ done: false, name: 'First Todo' }, { done: false, name: 'Second Todo' }] });
                var state = s.getState({ key: 'todos.1.name' });
                expect(state).toBe('Second Todo');
            });
            it('returns full array when is as last key', function () {
                givenTodoStore({ todos: [{ done: false, name: 'First Todo' }] });
                var state = s.getState(tds.todosCursor);
                expect(state[0].done).toBeFalsy();
            });
            function givenTodoStore(state) {
                s.setState(s.rootCursor, state);
            }
        });
    });
    describe('setState', function () {
        describe('without booting', function () {
            it('throws if key does not exist', function () {
                expect(function () { return s.setState(s.rootCursor, {}); })
                    .toThrow('Default state must be set before first usage through bootstrap(defaultState, () => { yourRenderCallback(); }).');
            });
        });
        describe('with booting', function () {
            var rootCursorTestFixture = {
                key: ''
            };
            beforeEach(function () {
                s.bootstrap({ key: null }, true);
            });
            it('creates empty object if cursor has not existing key', function () {
                var cursor = { key: 'invalid' };
                s.setState(cursor, {});
                expect(s.getState(s.rootCursor)).toEqual({ key: null, 'invalid': {} });
            });
            it('creates neseted empty objects if cursor has not existing key', function () {
                var cursor = { key: 'not.existing.key' };
                s.setState(cursor, {});
                expect(s.getState(s.rootCursor)).toEqual({ key: null, 'not': { 'existing': { key: {} } } });
            });
            it('freezes state', function () {
                givenStore({ some: { nested: { state: 'value' } } });
                var state = { nested: { state: 'newValue' } };
                s.setState({ key: 'some' }, state);
                expect(Object.isFrozen(state)).toBeTruthy();
            });
            it('sets nested state by cursor', function () {
                givenStore({ some: { nested: { state: 'value' } } });
                s.setState({ key: 'some' }, { nested: { state: 'newValue' } });
                expect((s.getState(rootCursorTestFixture)).some.nested.state).toBe('newValue');
            });
            it('sets nested state by cursor when current value of sub state is empty string', function () {
                givenStore({ some: { nested: { state: '' } } });
                s.setState({ key: 'some' }, { nested: { state: 'newValue' } });
                expect((s.getState(rootCursorTestFixture)).some.nested.state).toBe('newValue');
            });
            it('sets new instance of root state', function () {
                var initState = { some: { nested: { state: 'value' } } };
                givenStore(initState);
                s.setState({ key: 'some' }, { nested: { state: 'newValue' } });
                expect(s.getState(s.rootCursor)).not.toBe(initState);
            });
            it('logs new global state when debuging has been enabled', function () {
                var debugCallback = jasmine.createSpy('debugCallback');
                d.bootstrap(debugCallback);
                givenStore({ some: { nested: { state: 'value' } } });
                s.setState({ key: 'some' }, { nested: { state: 'newValue' } });
                expect(debugCallback).toHaveBeenCalledWith('Current state:', s.getState(s.rootCursor));
            });
            it('sets new instances of nodes which is in the path to root state', function () {
                var initState = { some: { nested: { state: 'value' } } };
                givenStore(initState);
                s.setState({ key: 'some.nested.state' }, 'newValue');
                var newState = s.getState(rootCursorTestFixture);
                expect(newState).not.toBe(initState);
                expect(newState.some).not.toBe(initState.some);
                expect(newState.some.nested).not.toBe(initState.some.nested);
            });
        });
        describe('with booting and dynamic/array cursor', function () {
            beforeEach(function () {
                s.bootstrap(tds.default());
            });
            it('sets nested state into array on specified index', function () {
                givenTodoStore({ todos: [{ done: false, name: 'First Todo' }, { done: false, name: 'Second Todo' }] });
                s.setState({ key: 'todos.1.name' }, 'New Todo Name');
                expect(s.getState({ key: 'todos.1.name' })).toBe('New Todo Name');
            });
            it('sets new state into array on specified index', function () {
                givenTodoStore({ todos: [{ done: false, name: 'First Todo' }] });
                s.setState({ key: 'todos.0' }, { done: false, name: 'Second Todo' });
                expect(s.getState({ key: 'todos.0' })).toEqual({ done: false, name: 'Second Todo' });
            });
            it('sets new instance of array when nested item has been changed', function () {
                var storedTodos = [{ done: false, name: 'First Todo' }, { done: false, name: 'Second Todo' }];
                givenTodoStore({ todos: storedTodos });
                s.setState({ key: 'todos.1.name' }, 'New Todo Name');
                expect(s.getState(tds.todosCursor)).not.toBe(storedTodos);
            });
            it('sets full array', function () {
                givenTodoStore({ todos: [{ done: false, name: 'First Todo' }] });
                s.setState(tds.todosCursor, [{ done: false, name: 'Second Todo' }, { done: false, name: 'Third Todo' }]);
                expect(s.getState(tds.todosCursor).length).toBe(2);
                expect(s.getState(tds.todosCursor)[0].name).toBe('Second Todo');
                expect(s.getState(tds.todosCursor)[1].name).toBe('Third Todo');
            });
            function givenTodoStore(state) {
                s.setState(s.rootCursor, state);
            }
        });
    });
    function givenStore(state) {
        s.setState(s.rootCursor, state);
    }
    function resetStore(withFreezing) {
        if (withFreezing === void 0) { withFreezing = false; }
        s.bootstrap(null, withFreezing);
    }
});
