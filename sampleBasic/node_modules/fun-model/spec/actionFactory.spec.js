"use strict";
var s = require('../src/store');
var tds = require('./todosState');
var af = require('../src/actionFactory');
var d = require('../src/debug');
describe('actionFactory', function () {
    var debugCallback;
    beforeEach(function () {
        resetStore();
        af.bootstrap(null);
        debugCallback = jasmine.createSpy('debugCallback');
        d.bootstrap(debugCallback);
    });
    describe('bootstrap', function () {
        it('reports initialization when debug has been enabled.', function () {
            af.bootstrap(null);
            expect(debugCallback).toHaveBeenCalledWith('Action factory has been initialized.', undefined);
        });
    });
    describe('array by cursor factory', function () {
        var renderCallback;
        beforeEach(function () {
            renderCallback = jasmine.createSpy('render');
            af.bootstrap(renderCallback);
        });
        it('changes state in array', function () {
            givenTodosStore({
                todos: [{ done: false, name: 'First todo' }, { done: false, name: 'Second todo' }]
            });
            var testAction = af.createAction({
                create: function (params) {
                    return { key: "todos." + params.index };
                }
            }, function (_state, params) { return params.todo; });
            testAction({ index: 1, todo: { done: false, name: 'New second todo' } });
            expect(getTodos()[1].done).toBeFalsy();
            expect(getTodos()[1].name).toBe('New second todo');
        });
        it('changes nested state on existing index', function () {
            givenTodosStore({
                todos: [{ done: false, name: 'First todo' }, { done: false, name: 'Second todo' }]
            });
            var testAction = af.createAction({ create: function (index) { return { key: "todos." + index + ".done" }; } }, function () { return true; });
            testAction(1);
            expect(getTodos()[1].done).toBeTruthy();
        });
        function givenTodosStore(state) {
            s.setState(s.rootCursor, state);
        }
        function getTodos() {
            return s.getState(tds.todosCursor);
        }
    });
    describe('createAction', function () {
        describe('when action threw during handling and catching have not been enabled', function () {
            var renderCallback;
            var throwingAction;
            beforeEach(function () {
                renderCallback = jasmine.createSpy('render');
                af.bootstrap(renderCallback, false);
                throwingAction = af.createAction(NestedCursorTestFixture, function () {
                    throw 'MyDummyException';
                });
            });
            it('throws', function () {
                expect(throwingAction).toThrow();
            });
        });
        describe('when action threw during handling and catching have been enabled', function () {
            var renderCallback;
            var throwingAction;
            beforeEach(function () {
                renderCallback = jasmine.createSpy('render');
                af.bootstrap(renderCallback, true);
                throwingAction = af.createAction(NestedCursorTestFixture, function () {
                    throw 'MyDummyException';
                });
            });
            it('does not throw', function () {
                expect(throwingAction).not.toThrow();
            });
            it('logs error', function () {
                throwingAction();
                expect(debugCallback).toHaveBeenCalledWith('Action factory has been initialized.', undefined);
            });
        });
        describe('when renderCallback has not been set', function () {
            it('does not throw if action has been only declared.', function () {
                var testAction = af.createAction(NestedCursorTestFixture, function (state) { return state; });
                expect(testAction).not.toBeUndefined();
            });
            it('throws if key does not exist', function () {
                expect(function () {
                    var testAction = af.createAction(NestedCursorTestFixture, function () { return { state: 'new nested state' }; });
                    testAction();
                }).toThrow('Render callback must be set before first usage through bootstrap(defaultState, () => { yourRenderCallback(); }).');
            });
        });
        describe('when renderCallback has been set', function () {
            var renderCallback;
            beforeEach(function () {
                renderCallback = jasmine.createSpy('render');
                af.bootstrap(renderCallback);
            });
            it('does not report current state when state has not been changed.', function () {
                givenStore(aState('nestedStateValue'));
                af.createAction(NestedCursorTestFixture, function (state) { return state; })();
                expect(debugCallback).not.toHaveBeenCalledWith('Global state has been changed.', undefined);
            });
            it('reports state changed when debug has been enabled.', function () {
                var newState = { state: 'newValue' };
                givenStore(aState('nestedStateValue'));
                af.createAction(NestedCursorTestFixture, function () { return newState; })();
                expect(debugCallback).toHaveBeenCalledWith('Global state has been changed.', undefined);
            });
            it('does not call render callback when state has not been changed', function () {
                givenStore(aState('nestedStateValue'));
                var testAction = af.createAction(NestedCursorTestFixture, function (state) { return state; });
                testAction();
                expect(renderCallback).not.toHaveBeenCalled();
            });
            it('calls render callback when state has been changed', function () {
                givenStore(aState('nestedStateValue'));
                var testAction = af.createAction(NestedCursorTestFixture, function () { return { state: 'newValue' }; });
                testAction();
                expect(renderCallback).toHaveBeenCalled();
            });
            it('calls nested actions', function () {
                givenStore(aState('value'));
                var nestedAction2 = af.createAction(NestedCursorTestFixture, function (state) {
                    return { state: state.state + " -> newValueFromNestedAction2" };
                });
                var nestedAction = af.createAction(NestedCursorTestFixture, function (state) {
                    nestedAction2();
                    return { state: state.state + " -> newValueFromNestedAction" };
                });
                af.createAction(NestedCursorTestFixture, function () {
                    nestedAction();
                    return { state: 'newValue' };
                })();
                expect(s.getState(NestedCursorTestFixture).state)
                    .toBe('newValue -> newValueFromNestedAction -> newValueFromNestedAction2');
            });
            it('does not throw on immutability violation in no debug mode', function () {
                d.bootstrap(undefined);
                givenStore(aState('nestedStateValue'));
                var testAction = af.createAction(SomeCursorTestFixture, function (state) {
                    state.nested.state = state.nested.state + 'newValue';
                    return state;
                });
                expect(function () {
                    testAction();
                }).not.toThrow();
            });
        });
    });
    describe('createActions', function () {
        describe('when renderCallback has not been set', function () {
            it('throws if key does not exist', function () {
                expect(function () {
                    var testAction = af.createActions({
                        cursor: NestedCursorTestFixture,
                        handler: function (state) { return state; }
                    });
                    testAction();
                }).toThrow('Render callback must be set before first usage through bootstrap(defaultState, () => { yourRenderCallback(); }).');
            });
        });
        describe('when renderCallback has been set', function () {
            var renderCallback;
            beforeEach(function () {
                renderCallback = jasmine.createSpy('render');
                af.bootstrap(renderCallback);
            });
            it('does not call render callback when all states have not been changed', function () {
                givenStore(aState('nestedStateValue'));
                var testAction = af.createActions({
                    cursor: NestedCursorTestFixture,
                    handler: function (state) { return state; }
                }, {
                    cursor: NestedCursorTestFixture,
                    handler: function (state) { return state; }
                });
                testAction();
                expect(renderCallback).not.toHaveBeenCalled();
            });
            it('calls render callback when one of states has been changed', function () {
                givenStore(aState('nestedStateValue'));
                var testAction = af.createActions({
                    cursor: SomeCursorTestFixture,
                    handler: function (state) { return { nested: state.nested, state: 'newStateValue' }; }
                }, {
                    cursor: NestedCursorTestFixture,
                    handler: function () { return { state: 'newNestedStateValue' }; }
                });
                testAction();
                expect(renderCallback).toHaveBeenCalled();
            });
            it('uses action as simple setter when no handler defined', function () {
                givenStore(aState('nestedStateValue'));
                var testAction = af.createAction(NestedStateCursorTestFixture);
                testAction('nestedStateValue');
                expect(renderCallback).not.toHaveBeenCalled();
                testAction('newNestedStateValue');
                expect(renderCallback).toHaveBeenCalled();
            });
        });
    });
});
function givenStore(state) {
    s.setState(s.rootCursor, state);
}
function resetStore(withFreezing) {
    if (withFreezing === void 0) { withFreezing = false; }
    s.bootstrap({ some: { nested: { state: null } } }, withFreezing);
}
function aState(nestedState, state) {
    if (nestedState === void 0) { nestedState = 'aNestedState'; }
    if (state === void 0) { state = 'aState'; }
    return { some: { nested: { state: nestedState }, state: state } };
}
var NestedCursorTestFixture = {
    key: 'some.nested'
};
var NestedStateCursorTestFixture = {
    key: 'some.nested.state'
};
var SomeCursorTestFixture = {
    key: 'some'
};
